module Main exposing (main)

import Expect
import Test exposing (describe, test)
import Test.Runner.Node exposing (Program, run)
import Parser as P exposing ((|.), (|=))



main : Program
main =
    run <|
        describe "Parser Tests"
            [ describe "int"
                [ test "Simple integer" <| \{} ->
                    P.run P.int "123456"
                        |> Expect.equal (Ok 123456)
                , test "Leading 0" <| \{} ->
                    P.run P.int "0123"
                        |> Expect.equal (Ok 0)
                , test "Trailing letters" <| \{} ->
                    P.run P.int "123a"
                        |> Expect.equal (Ok 123)
                , test "Failure case" <| \{} ->
                    P.run P.int "3.1415"
                        |> expectErr
                ]
            , describe "float"
                [ test "Simple float" <| \{} ->
                    P.run P.float "123"
                        |> Expect.equal (Ok 123)
                , test "Simple complex float" <| \{} ->
                    P.run P.float "3.1415"
                        |> Expect.equal (Ok 3.1415)
                , test "Period is not a valid float" <| \{} ->
                    P.run P.float "."
                        |> expectErr
                ]
            , describe "keyword"
                [ test "Simple keyword" <| \{} ->
                    P.run (P.keyword "true") "true"
                        |> Expect.equal (Ok {})
                , test "Is case sensetive" <| \{} ->
                    P.run (P.keyword "true") "True"
                        |> expectErr
                , test "Must match exactly" <| \{} ->
                    P.run (P.keyword "true") "false"
                        |> expectErr
                , test "Can be a prefix" <| \{} ->
                    P.run (P.keyword "true") "true!"
                        |> Expect.equal (Ok {})
                ]
            , describe "combinators"
                [ test "functions" <| \{} ->
                    let
                        parser =
                            P.succeed (\a b -> a + b)
                                |> P.keep P.int
                                |> P.skip (P.symbol "+")
                                |> P.keep P.int
                    in
                    P.run parser "3+5"
                        |> Expect.equal (Ok 8)
                , test "operators" <| \{} ->
                    let
                        parser =
                            P.succeed (\a b -> a + b)
                                |= P.int
                                |. P.symbol "+"
                                |= P.int
                    in
                    P.run parser "2+2"
                        |> Expect.equal (Ok 4)
                ]
            , describe "Chomping"
                [ test "chompIf" <| \{} ->
                    let
                        chomper =
                            P.succeed {}
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.getChompedString
                    in
                    P.run chomper "abc test"
                        |> Expect.equal (Ok "abc")
                , test "chompIf failure" <| \{} ->
                    let
                        chomper =
                            P.succeed {}
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.skip (P.chompIf Char.isAlpha)
                                |> P.getChompedString
                    in
                    P.run chomper "a2c test"
                        |> Expect.err
                , test "chompIf unicode" <| \{} ->
                    let
                        chomper =
                            P.succeed {}
                                |> P.skip (P.chompIf (\_ -> True))
                                |> P.skip (P.chompIf (\_ -> True))
                                |> P.skip (P.chompIf (\_ -> True))
                                |> P.getChompedString
                    in
                    P.run chomper "a𤭢c test"
                        |> Expect.equal (Ok "a𤭢c")
                , test "chompUntil" <| \{} ->
                    let
                        chomper =
                            P.succeed (\value { row, col } -> { value = value, row = row, column = col })
                                |> P.keep (P.getChompedString (P.chompUntil "bar"))
                                |> P.keep P.getPosition
                    in
                    -- A little bit more complicated than it needs to be, in order to check
                    -- parser state
                    P.run chomper "foobar"
                        |> Expect.equal (Ok { value = "foobar", row = 1, column = 7 })
                ]
            ]


expectErr : Result err ok -> Expect.Expectation
expectErr result =
    when result is
        Err _ ->
            Expect.pass

        Ok _ ->
            Expect.fail "I expected this test to fail with an Err case"
